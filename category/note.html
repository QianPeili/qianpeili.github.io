<!DOCTYPE html>
<html lang="cn">
<head>
        <title>爪了个子</title>
        <meta charset="utf-8" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://qianpeili.github.io/">爪了个子 <strong>我所见，我所想</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/archives.html">Archives</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
        </ul></nav><!-- /#menu -->
<section id="content">
<h2>Articles in the note category</h2>

<ol id="post-list">
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="http://qianpeili.github.io/gode-yi-lai-guan-li-gong-ju-govendor.html" rel="bookmark" title="Permalink to Go的依赖管理工具govendor">Go的依赖管理工具govendor</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-05-22T18:11:00+08:00"> 周一 22 五月 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="http://qianpeili.github.io/author/qianpeili.html">QianPeili</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>依赖管理是我接触 go 以来，觉得比较麻烦的事情。
不过在 go-1.5 版本中，出现了一个 <code>vendor</code> 的概念，并且 <code>vendor</code> 作为一个默认功能存在于1.7之后的版本中。</p>
<p>vendor的概念就类似于python中的 <code>virtualenv</code> 建立的 <code>env</code>，它是一个文件夹，里面存放了项目所用的依赖。如果项目中有个文件 import 了第三方的 package，而这个 package 又存在项目的 vendor 目录中，这个文件编译的时候会从 vendor 中 import 这个 package</p>
<p>比如：</p>
<div class="highlight"><pre><span></span>$GOPATH
|   src/
|   |   project/
|   |   |   main.go
|   |   |   vendor/
|   |   |   |   github.com/pkg/sftp/
|   |   |   |   golang.org/x …</pre></div> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="http://qianpeili.github.io/tcpjing-shou-shi-yan.html" rel="bookmark" title="Permalink to tcp经受时延">tcp经受时延</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-05-20T16:15:00+08:00"> 周六 20 五月 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="http://qianpeili.github.io/author/perrie.html">perrie</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>学 <code>TCP/IP</code> 协议听到最多的就是三次握手和四次挥手协议了吧。由于最近在折腾 <code>tcpdump</code> ，就想着实战抓一下 <code>tcp</code> 协议的这个握手和挥手协议。于是我在本地向内网测试机器的服务上发起了一个
 <code>POST</code> 请求，抓到如下信息：</p>
<div class="highlight"><pre><span></span><span class="mi">15</span><span class="o">:</span><span class="mi">05</span><span class="o">:</span><span class="mf">03.904647</span> <span class="n">IP</span> <span class="n">socket</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="mi">56558</span> <span class="o">&gt;</span> <span class="n">socket</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="mi">3000</span><span class="o">:</span> <span class="n">Flags</span> <span class="o">[</span><span class="n">S</span><span class="o">],</span> <span class="n">seq</span> <span class="mi">2090421259</span><span class="o">,</span> <span class="n">win</span> <span class="mi">64240</span><span class="o">,</span> <span class="n">options</span> <span class="o">[</span><span class="n">mss</span> <span class="mi">1460</span><span class="o">,</span><span class="n">nop</span><span class="o">,</span><span class="n">wscale</span> <span class="mi">8</span><span class="o">,</span><span class="n">nop</span><span class="o">,</span><span class="n">nop</span><span class="o">,</span><span class="n">sackOK</span><span class="o">],</span> <span class="n">length</span> <span class="mi">0</span>
<span class="mi">15</span><span class="o">:</span><span class="mi">05</span><span class="o">:</span><span class="mf">03.904699</span> <span class="n">IP</span> <span class="n">socket</span><span class="o">-</span><span class="n">server</span><span class="o">.</span><span class="mi">3000</span> <span class="o">&gt;</span> <span class="n">socket …</span></pre></div> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="http://qianpeili.github.io/tcpdumpde-shi-yong-shi-li.html" rel="bookmark" title="Permalink to tcpdump的使用实例">tcpdump的使用实例</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2017-05-20T13:46:00+08:00"> 周六 20 五月 2017 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="http://qianpeili.github.io/author/perrie.html">perrie</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>给出了一些tcpdump的使用例子，实践才是学习的好办法~</p> </div><!-- /.entry-content -->
        </article></li>
        <li><article class="hentry">
                <header> <h2 class="entry-title"><a href="http://qianpeili.github.io/replace-type-code-with-statestrategy.html" rel="bookmark" title="Permalink to Replace Type Code With State/Strategy">Replace Type Code With State/Strategy</a></h2> </header>
                <footer class="post-info">
                    <time class="published" datetime="2016-12-26T20:55:00+08:00"> 周一 26 十二月 2016 </time>
                    <address class="vcard author">By
                        <a class="url fn" href="http://qianpeili.github.io/author/qianpeili.html">QianPeili</a>
                    </address>
                </footer><!-- /.post-info -->
                <div class="entry-content"> <p>今天在阅读《重构：改善既有代码的设计》第一个案例中，遇到了一个<strong>replace type code with state/strategy</strong>的概念，不是很了解，
但大概懂了意思。决定用<code>python</code>实现一下其代码。</p>
<p>觉得主要思想是：</p>
<p>一个对象(<code>Movie</code>)有一个属性(<code>price_code</code>)，这个属性的不同会导致对象的方法(<code>get_charge</code>)返回不同的结果。</p>
<p>最开始的想法肯定是用subclass进行分类，但是一部电影可以更换<code>price_code</code>，一个对象没法更换其所属类，所以直接建立一个<code>price</code>对象作为属性，改变<code>price_code</code>时，即改变了<code>price</code>对象。</p>
<p>重构前的代码：</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Movie</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>

    <span class="nx">REGULAR</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nx">NEW_RELEASE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="nx">CHILDRENS</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nx">def</span> <span class="nx">__init__ …</span></pre></div> </div><!-- /.entry-content -->
        </article></li>
</ol><!-- /#posts-list -->
</section><!-- /#content -->
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>